\begin{Verbatim}[commandchars=\\\{\}]
\PYGdefault{c+c1}{// copy out function implementation}
\PYGdefault{k+kt}{void} \PYGdefault{n+nf}{copy\PYGdefaultZus{}out}\PYGdefault{p}{(}\PYGdefault{k+kt}{char}\PYGdefault{o}{*} \PYGdefault{n}{dest}\PYGdefault{p}{,} \PYGdefault{n}{list}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{k+kt}{char}\PYGdefault{o}{*\PYGdefaultZgt{}*} \PYGdefault{n}{arguments}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
	\PYGdefault{c+c1}{// create the file locally}
	\PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{output\PYGdefaultZus{}file} \PYGdefault{o}{=} \PYGdefault{n}{open}\PYGdefault{p}{(}\PYGdefault{n}{dest}\PYGdefault{p}{,} \PYGdefault{n}{O\PYGdefaultZus{}RDWR} \PYGdefault{o}{|} \PYGdefault{n}{O\PYGdefaultZus{}CREAT} \PYGdefault{o}{|} \PYGdefault{n}{O\PYGdefaultZus{}TRUNC}\PYGdefault{p}{,} \PYGdefault{n}{S\PYGdefaultZus{}IRWXU}\PYGdefault{p}{);}

	\PYGdefault{c+c1}{// find the fat entry}
	\PYGdefault{n}{Fat16Entry} \PYGdefault{n}{file\PYGdefaultZus{}entry} \PYGdefault{o}{=} \PYGdefault{n}{follow\PYGdefaultZus{}path}\PYGdefault{p}{(}\PYGdefault{n}{arguments}\PYGdefault{p}{,} \PYGdefault{n+nb}{true}\PYGdefault{p}{);}

	\PYGdefault{c+c1}{// save the file size}
	\PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{file\PYGdefaultZus{}size} \PYGdefault{o}{=} \PYGdefault{n}{file\PYGdefaultZus{}entry}\PYGdefault{p}{.}\PYGdefault{n}{file\PYGdefaultZus{}size}\PYGdefault{p}{;}

	\PYGdefault{c+c1}{// buffer to read in clusters}
	\PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{cluster\PYGdefaultZus{}size} \PYGdefault{o}{=} \PYGdefault{n}{BS}\PYGdefault{p}{.}\PYGdefault{n}{sectors\PYGdefaultZus{}per\PYGdefaultZus{}cluster} \PYGdefault{o}{*} \PYGdefault{n}{BS}\PYGdefault{p}{.}\PYGdefault{n}{sector\PYGdefaultZus{}size}\PYGdefault{p}{;}
	\PYGdefault{k+kt}{char} \PYGdefault{n}{cluster\PYGdefaultZus{}buffer}\PYGdefault{p}{[}\PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{];}

	\PYGdefault{c+c1}{// go to the first cluster and read in the data}
	\PYGdefault{n}{lseek}\PYGdefault{p}{(}\PYGdefault{n}{DISK}\PYGdefault{p}{,} \PYGdefault{n}{first\PYGdefaultZus{}sector\PYGdefaultZus{}of\PYGdefaultZus{}cluster}\PYGdefault{p}{(}\PYGdefault{n}{file\PYGdefaultZus{}entry}\PYGdefault{p}{.}\PYGdefault{n}{starting\PYGdefaultZus{}cluster}\PYGdefault{p}{,} \PYGdefault{n+nb}{true}\PYGdefault{p}{)} \PYGdefault{o}{*} \PYGdefault{n}{BS}\PYGdefault{p}{.}\PYGdefault{n}{sector\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{n}{SEEK\PYGdefaultZus{}SET}\PYGdefault{p}{);}
	\PYGdefault{n}{read}\PYGdefault{p}{(}\PYGdefault{n}{DISK}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cluster\PYGdefaultZus{}buffer}\PYGdefault{p}{,} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{);}

	\PYGdefault{c+c1}{// check if there are more clusters}
	\PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{short} \PYGdefault{n}{fat\PYGdefaultZus{}value} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
	\PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{get\PYGdefaultZus{}fat\PYGdefaultZus{}value}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{fat\PYGdefaultZus{}value}\PYGdefault{p}{,} \PYGdefault{n+nb}{true}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
		\PYGdefault{c+c1}{// write to the output file and update the remaining file size}
		\PYGdefault{n}{write}\PYGdefault{p}{(}\PYGdefault{n}{output\PYGdefaultZus{}file}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cluster\PYGdefaultZus{}buffer}\PYGdefault{p}{,} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{);}
		\PYGdefault{n}{file\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZhy{}=} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{;}

		\PYGdefault{c+c1}{// move to the next cluster}
		\PYGdefault{n}{lseek}\PYGdefault{p}{(}\PYGdefault{n}{DISK}\PYGdefault{p}{,} \PYGdefault{n}{first\PYGdefaultZus{}sector\PYGdefaultZus{}of\PYGdefaultZus{}cluster}\PYGdefault{p}{(}\PYGdefault{n}{fat\PYGdefaultZus{}value}\PYGdefault{p}{,} \PYGdefault{n+nb}{true}\PYGdefault{p}{)} \PYGdefault{o}{*} \PYGdefault{n}{BS}\PYGdefault{p}{.}\PYGdefault{n}{sector\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{n}{SEEK\PYGdefaultZus{}SET}\PYGdefault{p}{);}

		\PYGdefault{c+c1}{// pass by value and reference at once could cause issues}
		\PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{short} \PYGdefault{n}{active\PYGdefaultZus{}cluster} \PYGdefault{o}{=} \PYGdefault{n}{fat\PYGdefaultZus{}value}\PYGdefault{p}{;}
		\PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{n}{get\PYGdefaultZus{}fat\PYGdefaultZus{}value}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{fat\PYGdefaultZus{}value}\PYGdefault{p}{,} \PYGdefault{n+nb}{false}\PYGdefault{p}{,} \PYGdefault{n}{active\PYGdefaultZus{}cluster}\PYGdefault{p}{))}
		\PYGdefault{p}{\PYGdefaultZob{}}
			\PYGdefault{n}{read}\PYGdefault{p}{(}\PYGdefault{n}{DISK}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cluster\PYGdefaultZus{}buffer}\PYGdefault{p}{,} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{);}

			\PYGdefault{c+c1}{// write to the output file and update the remaining file size}
			\PYGdefault{n}{write}\PYGdefault{p}{(}\PYGdefault{n}{output\PYGdefaultZus{}file}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cluster\PYGdefaultZus{}buffer}\PYGdefault{p}{,} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{);}
			\PYGdefault{n}{file\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZhy{}=} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{;}

			\PYGdefault{c+c1}{// check if there is another cluster}
			\PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{file\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZlt{}=} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{)} \PYGdefault{k}{break}\PYGdefault{p}{;}

			\PYGdefault{c+c1}{// else, keep going}
			\PYGdefault{n}{active\PYGdefaultZus{}cluster} \PYGdefault{o}{=} \PYGdefault{n}{fat\PYGdefaultZus{}value}\PYGdefault{p}{;}

			\PYGdefault{c+c1}{// move to the next cluster}
			\PYGdefault{n}{lseek}\PYGdefault{p}{(}\PYGdefault{n}{DISK}\PYGdefault{p}{,} \PYGdefault{n}{first\PYGdefaultZus{}sector\PYGdefaultZus{}of\PYGdefaultZus{}cluster}\PYGdefault{p}{(}\PYGdefault{n}{fat\PYGdefaultZus{}value}\PYGdefault{p}{,} \PYGdefault{n+nb}{true}\PYGdefault{p}{)} \PYGdefault{o}{*} \PYGdefault{n}{BS}\PYGdefault{p}{.}\PYGdefault{n}{sector\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{n}{SEEK\PYGdefaultZus{}SET}\PYGdefault{p}{);}
		\PYGdefault{p}{\PYGdefaultZcb{}}
		\PYGdefault{c+c1}{// read one last time}
		\PYGdefault{n}{read}\PYGdefault{p}{(}\PYGdefault{n}{DISK}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cluster\PYGdefaultZus{}buffer}\PYGdefault{p}{,} \PYGdefault{n}{cluster\PYGdefaultZus{}size}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{c+c1}{// write the remaining bytes to the output file}
	\PYGdefault{n}{write}\PYGdefault{p}{(}\PYGdefault{n}{output\PYGdefaultZus{}file}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cluster\PYGdefaultZus{}buffer}\PYGdefault{p}{,} \PYGdefault{n}{file\PYGdefaultZus{}size}\PYGdefault{p}{);}

	\PYGdefault{c+c1}{// close the file}
	\PYGdefault{n}{close}\PYGdefault{p}{(}\PYGdefault{n}{output\PYGdefaultZus{}file}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}
\end{Verbatim}
